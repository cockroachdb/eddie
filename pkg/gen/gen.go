// Copyright 2019 The Cockroach Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
// implied. See the License for the specific language governing
// permissions and limitations under the License.

// Package gen contains the code-generator.
package gen

import (
	"bytes"
	"fmt"
	"go/ast"
	"go/format"
	"go/token"
	"go/types"
	"io/ioutil"
	"log"
	"os"
	"path/filepath"
	"strings"
	"text/template"

	"github.com/cockroachdb/eddie/pkg/util"
	"github.com/pkg/errors"
	"golang.org/x/tools/go/packages"
)

const (
	contractPkg = util.Base + "contract"
	rtPkg       = util.Base + "rt"
)

// Eddie generates a contract-enforcer binary.  See discussion on the
// public API for details on the patterns that it looks for.
type Eddie struct {
	BuildFlags []string
	Dir        string
	Logger     *log.Logger
	Name       string
	Outfile    string
	Packages   []string

	contracts []types.Object

	// For testing only, causes the compiled enforcer to be emitted
	// as a golang plugin.
	Plugin bool
}

// Execute allows the generator to be invoked programmatically.
func (e *Eddie) Execute() error {
	if e.Logger == nil {
		e.Logger = log.New(os.Stdout, "", 0 /* no flags */)
	}

	if e.Name == "" {
		e.Name = "enforcer"
	}

	if e.Outfile == "" {
		e.Outfile = e.Name + ".go"
	}

	if err := e.findContracts(); err != nil {
		return err
	}
	if e.contracts == nil {
		return errors.New("no contracts found; missing var _ contract.Contract = &YourContract{} ?")
	}
	return e.writeBinary()
}

// findContracts looks for some very specific patterns in the original
// source code, so we're just going to run through the AST nodes, rather
// than try to back this out of the SSA form of the implicit init()
// function.
//
// Specifically, it looks for:
//   var _ Contract = MyContract{}
//   var _ Contract = &MyContract{}
func (e *Eddie) findContracts() error {
	cfg := &packages.Config{
		BuildFlags: e.BuildFlags,
		Dir:        e.Dir,
		Mode:       packages.LoadAllSyntax,
	}
	pkgs, err := packages.Load(cfg, e.Packages...)
	if err != nil {
		return err
	}

	// Look for the type assertion.
	for _, pkg := range pkgs {
		for _, f := range pkg.Syntax {
			for _, d := range f.Decls {
				if v, ok := d.(*ast.GenDecl); ok && v.Tok == token.VAR {
					for _, s := range v.Specs {
						if v, ok := s.(*ast.ValueSpec); ok &&
							len(v.Values) == 1 &&
							v.Names[0].Name == "_" {
							// assignmentType is the LHS type.
							assignmentType, _ := pkg.TypesInfo.TypeOf(v.Type).(*types.Named)
							if assignmentType == nil ||
								!util.InPackage(assignmentType.Obj(), contractPkg) ||
								assignmentType.Obj().Name() != "Contract" {
								continue
							}
							// value:Type is the type of the RHS. It should be a named
							// type or a pointer thereto.
							valueType := pkg.TypesInfo.TypeOf(v.Values[0])
							if ptr, ok := valueType.(*types.Pointer); ok {
								valueType = ptr.Elem()
							}
							if named, ok := valueType.(*types.Named); ok {
								e.contracts = append(e.contracts, named.Obj())
							}
						}
					}
				}
			}
		}
	}

	return nil
}

// writeBinary generates a file containing a main function which
// configures the runtime and then compiles in into an executable
// binary.
func (e *Eddie) writeBinary() error {
	packagePath := func(obj types.Object) string {
		// Return the package path, but remove any vendor prefix.
		path := obj.Pkg().Path()
		if idx := strings.LastIndex(path, "/vendor/"); idx > 0 {
			path = path[idx+8:]
		}
		return path
	}

	fnMap := template.FuncMap{
		"ContractPkg": func() string { return contractPkg },
		"Contracts":   func() []types.Object { return e.contracts },
		"Help": func(obj types.Object) string {
			// Ideally, this would emit the struct definition and
			// additional documentation. For now, we'll create a godoc
			// link for users to follow.
			return fmt.Sprintf("`contract:%s\n\thttps://godoc.org/%s#%s`",
				obj.Name(), packagePath(obj), obj.Name())
		},
		"Name":        func() string { return e.Name },
		"PackagePath": packagePath,
		"RtPkg":       func() string { return rtPkg },
	}

	t, err := template.New("root").Funcs(fnMap).Parse(`
// File generated by eddie; DO NOT EDIT
package main

import (
	ct "{{ ContractPkg }}"
	rt "{{ RtPkg }}"
	{{ range $idx, $c := Contracts -}}
		c{{ $idx }} "{{ PackagePath $c }}"
	{{ end }}
)

var Enforcer = rt.Enforcer{
	Contracts: ct.Providers {
	{{ range $idx, $c := Contracts -}}
		"{{ $c.Name }}" : {
			New: func() ct.Contract { return &c{{ $idx }}.{{ $c.Name}}{} },
			Help: {{ Help $c }},
		},
	{{ end }}
	},
	Name: "{{ Name }}",
}

func main() {
	Enforcer.Main()
}
`)
	if err != nil {
		return err
	}

	var src bytes.Buffer
	if err := t.Execute(&src, nil); err != nil {
		return err
	}

	// Formatting this code isn't strictly necessary, but it does
	// make it easier to inspect.
	var formatted []byte
	if formatted, err = format.Source(src.Bytes()); err != nil {
		e.Logger.Print(src.String())
		return err
	}
	src.Reset()
	src.Write(formatted)

	main, err := filepath.Abs(e.Outfile)
	if err != nil {
		return err
	}
	if err := ioutil.WriteFile(main, src.Bytes(), 0644); err != nil {
		return err
	}
	e.Logger.Printf("wrote source to %s", main)

	return nil
}
